<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>bes: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bes
   &#160;<span id="projectnumber">Updated for version 3.20.8-314</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_modules_dmrpp_module_data_README.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This directory (<em>data</em>) contains:</p><ul>
<li>module test data</li>
<li>The _dmr++_ tools: scripts, source code, and production rules for tools that can be used to create and process <code>hdf5</code>/<code>netcdf-4</code> data files to create portable _dmr++_ files whose binary data objects are held in a web object store like AWS S3.</li>
</ul>
<h2>Overview</h2>
<p>We have developed an initial set of tools that enable a data provider to easily serve data stored in Amazon's S3 Web Object Store. In the current implementaiton, the data must be stored in HDF5 or NetCDF4 files. The data do not, however, have to be reformatted to be used with the Hyrax server. Furthermore, the data objects are subset 'in-place' from S3 instead of first transferring the object and then serving it, resulting in lower response latency than other solutions for S3 darta access such as those based on FUSE filesystems. For data users, access is seamless - there is no difference between access to data stored in S3 or on spinning disk.</p>
<p>We have conducted tests of this software and the Google Cloud Store and found that it works with that Web Object Store as well. In fact, reconfiguration to GCS is trivial.</p>
<h3>dmr++</h3>
<p>The _dmr++_ files are the control data used by the server to enable 'in-place' access and subsetting of data in S3.</p>
<p><b>self-contained and portable</b>: The _dmr++_ files are self contained. They can be served by any Hyrax server (version 1.16.0 or higher) simply by placing them in the server's data file system.</p>
<p><b>size</b>: The _dmr++_ files are typically very much smaller than their source <code>hdf5</code>/<code>nectdf-4</code> files, by as much as 2 or even 3 orders of magnitude (YMMV).</p>
<h2>dmr++ tools</h2>
<p>There are three programs for building _dmr++_ files:</p><ul>
<li>The program <code>get_dmrpp</code> builds a single _dmr++_ file from a single <code>netcdf-4</code>/<code>hdf5</code> file.</li>
<li>The program <code>ingest_filesystem</code> builds a collection of _dmr++_ files from from data held in the locally mounted filesystem.</li>
<li>The program <code>ingest3bucket</code> builds a collection of _dmr++_ files from from data held in Amazon's S3 storage.</li>
</ul>
<p>NOTE: Organizationally, this directory (<em>data</em>) and it's child directory <em>dmrpp</em> are arranged in this hierarchy in order to mimic the deployment structure resulting from running "make install". Most modules do not need to do this but since _dmr++_ files reference other files, and they do so using paths relative the BES Catalog Root the mimicry is required.</p>
<p>NOTE: Examples can be run as shown from the <em>bes/modules/dmrpp___module/data</em> directory.</p>
<h2>building the software</h2>
<p>In order for these programs (shell scripts) to function correctly a localization step must take place. This happens when the parent software (the <code>dmrpp_module</code>) is built and installed as part of the BES. Once this is done the scripts will have been installed and should be in <code>$prefix/bin</code> and ready to use.</p>
<h2><code>get_dmrpp</code> - build a <em>dmr++_ file from an _hdf5</em>/_nectdf-4_ file.</h2>
<p>The <code>get_dmrpp</code> shell script generates a single _dmr++_ file from a single netcdf-4/hdf5 file. It is used by both <code>ingest_filesystem</code> and <code>ingest_s3bucket</code>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Usage: get_dmrpp [options] &lt;hdf5_file&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Write the DMR++ for hdf5_file to stdout</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;By default the BES Data Root directory is set to the CWD. This </div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;utility will add an entry to the bes.log specified in the </div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;configuration file. The DMR++ is built using the DMR as returned </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;by the HDF5 handler, using options as set in the bes </div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;configuration file found here.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;-h: Show help</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;-v: Verbose: Print the DMR too</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;-V: Very Verbose: print the DMR, the command and the configuration</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    file used to build the DMR</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;-r: Just print the DMR that will be used to build the DMR++</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;-u: The binary object URL for use in the DMR++ file</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;-d: Data root directory for the BES.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;-o: The name of the file  to create.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;Limitations: </div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;* The pathanme to the hdf5 file must be relative from the</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  directory where this command was run; absolute paths will not work. </div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;* The build_dmrpp command must be in the CWD. </div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;* The bes conf template has to build by hand. jhrg 5/11/18</div></div><!-- fragment --><h3>example 1</h3>
<p>Creates a <em>dmr++_ file (_foo.dmrpp</em>) whose binary object URL is a file URL containing the fully qualifed path to the source data file as it's value.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;get_dmrpp -v -d `pwd` -o foo.dmrpp -u file://`pwd`/dmrpp/chunked_shuffled_fourD.h5 dmrpp/chunked_shuffled_fourD.h5</div></div><!-- fragment --> <dl>
<dt><code>-v</code> </dt>
<dd><em>verbose mode</em> </dd>
<dt><code>-d <code>pwd</code></code> </dt>
<dd><em>The data root directory to be used by the BES. In this example it is set to the current directory.</em> </dd>
<dt><code>-o foo.dmrpp</code> </dt>
<dd><em>The dmr++ content will be written to the file foo.dmrpp&lt;</em> </dd>
<dt><code>-u <a href="file://">file://</a><code>pwd</code>/dmrpp/chunked_shuffled_fourD.h5</code> </dt>
<dd><em>The dmr++ file will use this full qualified file URL as its binary data location.</em> </dd>
<dt><code>dmrpp/chunked_shuffled_fourD.h5</code> </dt>
<dd><em>The hdf5 file from which to build the dmr++ file.</em> </dd>
</dl>
<h3>example 2</h3>
<p>Creates a <em>dmr++_ file (_foo.dmrpp</em>) whose binary object URL references an object in Amazon's S3.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;get_dmrpp -v -d `pwd` -o foo.dmrpp -u https://s3.amazonaws.com/opendap.scratch/data/dmrpp/chunked_fourD.h5  dmrpp/chunked_shuffled_fourD.h5</div></div><!-- fragment --> <dl>
<dt><code>-v</code> </dt>
<dd><em>verbose mode</em> </dd>
<dt><code>-d <code>pwd</code></code> </dt>
<dd><em>The data root directory to be used by the BES. In this example it is set to the current directory.</em> </dd>
<dt><code>-o foo.dmrpp</code> </dt>
<dd><em>The dmr++ content will be written to the file foo.dmrpp&lt;</em> </dd>
<dt><code>-u <a href="https://s3.amazonaws.com/opendap.scratch/data/dmrpp/chunked_fourD.h5">https://s3.amazonaws.com/opendap.scratch/data/dmrpp/chunked_fourD.h5</a></code> </dt>
<dd><em>The dmr++ file will use this AWS S3 object URL as its binary data location..</em> </dd>
<dt><code>dmrpp/chunked_shuffled_fourD.h5</code> </dt>
<dd><em>The hdf5 file from which to build the dmr++ file.</em> </dd>
</dl>
<h2><code>ingest_filesystem</code> - building _dmr++_ files from local files.</h2>
<p>The shell script <code>ingest_filesystem</code> is used to crawl through a branch of the local filesystem, identifying files that match a regular expression (default or supplied), and then attempting to build a _dmr++_ file for each matching file using the <code>get_dmrpp</code> program.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Usage: ingest_filesystem [options] </div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Crawl filesystem and make a DMR++ for every dataset matching the</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;default or supplied regex.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;The DMR++ is built using the DMR as returned by the HDF5 handler,</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;using options as set in the bes configuration file used by get_dmrpp.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;-h: Show help</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;-v: Verbose: Print the DMR too</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;-V: Very Verbose: Verbose plus so much more!</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;-j: Just print the DMR that will be used to build the DMR++</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;-u: The base endpoint URL for the DMRPP data objects. The assumption</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    is that they will be organized the same way the source dataset </div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    files below the &quot;data_root&quot; (see -d)</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    (default: file://${data_root})</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;-d: The local filesystem root from which the data are to be ingested. </div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    The filesystem will be searched beginning at this point for files </div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    whose names match the dataset match regex (see -r).</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    (default: $CWD)</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;-t: The target directory for the dmrpp files. Below this point</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    the organization of the data files vis-a-vis their &quot;/&quot; path</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    separator divided names will be replicated and dmr++ files placed </div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    accordingly.</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    (default: $CWD)</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;-r: The dataset match regex used to screen the base filesystem </div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    for datasets. </div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    (default: &quot;^.*\\.(h5|he5|nc4)(\\.bz2|\\.gz|\\.Z)?$&quot;)</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;-f: Use &quot;find&quot; to list all regular files below the data root directory </div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    and store the list in &quot;${ALL_FILES}&quot; The the dataset match regex is applied</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    to each line in ${ALL_FILES} and the matching data files list is placed in</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    &quot;${DATA_FILES}&quot;. If this option is omitted the files named in &quot;${DATA_FILES}&quot;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;     (if any) will be processed.</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    (default: Not Set)</div></div><!-- fragment --> <h3>example 1</h3>
<p>In its simplest invocation, <code>ingest_filesystem</code>'s defaults will cause it check for the file <code>./data_files.txt</code>. If found <code>ingest_filesystem</code> will treat every line in <code>./data_files.txt</code> as a fully qualifed path to an <code>hdf5</code>/<code>netcdf-4</code> file for which a <code>dmr++</code> file is to be computed. By default the output tree will be placed in the current working directory. The base end point for the <code>dmr++</code> binary object will be set to the current working directory.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ingest_filesystem </div></div><!-- fragment --><h3>example 2</h3>
<p>In this invocation, <code>ingest_filesystem</code> crawls the local filesystem beginning with the CWD every file that matches the default regular expression (<code>^.*\\.(h5|he5|nc4)(\\.bz2|\\.gz|\\.Z)?$</code>) will be treated as an <code>hdf5</code>/<code>netcdf-4</code> file for which a <code>dmr++</code> file is to be computed. The output tree will be placed in a directory called scratch in the current working directory. The base URL for the <code>dmr++</code> binary objects will be set to the current working directory.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ingest_filesystem -f -t scratch</div></div><!-- fragment --> <dl>
<dt><code>-f</code> </dt>
<dd><em>Use the <code>find</code> command along with the regular expression to traverse the filesystem and locate all of the matching files. These file names are placed, as fully qualified path names, in the file <code>./data_files.txt</code> to be reused or hand edited if needed.</em> </dd>
<dt><code>-t scratch</code> </dt>
<dd><em>Sets name of the directory to which the dmr++ output tree will be written to $CWD/scratch</em> </dd>
</dl>
<h3>example 3</h3>
<p>In this invocation, <code>ingest_filesystem</code> crawls the local filesystem beginning at <code>/usr/share/hyrax</code>. Every file that matches the default regular expression (<code>^.*\\.(h5|he5|nc4)(\\.bz2|\\.gz|\\.Z)?$</code>) will be treated as an <code>hdf5</code>/<code>netcdf-4</code> file for which a <code>dmr++</code> file is to be computed. The output tree will be placed in <code>/tmp/dmrpp</code>. The base URL for the <code>dmr++</code> binary objects will be set to the AWS S3 bucket URL <code><a href="https://s3.amazonaws.com/cloudydap">https://s3.amazonaws.com/cloudydap</a></code> .</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ingest_filesystem -f -u https://s3.amazonaws.com/cloudydap -d /usr/share/hyrax -t /tmp/dmrpp</div></div><!-- fragment --> <dl>
<dt><code>-f</code> </dt>
<dd><em>Use the <code>find</code> command along with the regular expression to traverse the filesystem and locate all of the matching files. These file names are placed, as fully qualified path names, in the file <code>./data_files.txt</code> to be reused or hand edited if needed.</em> </dd>
<dt><code>-u <a href="https://s3.amazonaws.com/cloudydap">https://s3.amazonaws.com/cloudydap</a></code> </dt>
<dd><em>Sets the base URL for the web accessible binary data files to the AWS S3 bucket URL <code><a href="https://s3.amazonaws.com/cloudydap">https://s3.amazonaws.com/cloudydap</a></code> File paths relative to the BES DataRoot will be appended to this URL to form the binary access URL for each dmr++ file. </em> </dd>
<dt><code>-d /usr/share/hyrax</code> </dt>
<dd><em>Sets the BES data root to <code>/usr/share/hyrax</code> for this invocataion. Since the -f option is also present the crawl of the file system will begin here.</em> </dd>
<dt><code>-t /tmp/dmrpp</code> </dt>
<dd><em>Sets the directory to which the dmr++ output tree will be written to: <code>/tmp/dmrpp</code></em> </dd>
</dl>
<h2><code>ingest_s3bucket</code> - building _dmr++_ files from files held in S3.</h2>
<p>The shell script <code>ingest_s3bucket</code> utilizes the AWS CLI to list the contents of an S3 bucket. The name of each object in the bucket is checked against either the defaukt or user supplied regex. Each matching file is retrieved from S3 and then a _dmr++_ is built from the retrived data object. Once the _dmr++_ file is built the downloaded object is deleted unless otherwise instructed. The code relies on the AWS CLI being installed and configured using the <code>aws configure</code> command (or it's equivalent).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; Usage: ingest_s3bucket [options] </div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; List an AWS S3 bucket and make a DMR++ for every dataset matching the</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; default (or supplied) regex.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; The DMR++ is built using the DMR as returned by the HDF5 handler,</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; using options as set in the bes configuration file used by get_dmrpp.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; -h: Show help</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; -v: Verbose: Print the DMR too</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; -V: Very Verbose: Verbose plus so much more. Your eyes will water from</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;     the scanning of it all.</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160; -j: Just print the DMR that will be used to build the DMR++</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; -s: The endpoint URL for the S3 datastore. </div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;     (default: https://s3.amazonaws.com)</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160; -b: The S3 bucket name. </div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;     (default: cloudydap)</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160; -d: The &quot;local&quot; filesystem root for the downloaded data. </div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;     (default: ./s3_data/bucket_name})</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; -t: The target directory for the dmrpp files. Below this point</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;     the structure of the bucket objects vis-a-vis their &quot;/&quot; path</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;     separator divided names will be replicted and dmr++ placed into</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;     it accordingly.</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;     (default: $CWD)</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; -f: Retrieve object list from S3 bucket into the list file for the bucket,</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;     apply the dataset match regex to the object names to create</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;     the data files list. If this is omitted the files named in an </div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;     exisiting bucket list file (if any) will be processed.</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;     (default: Not Set)</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160; -r: The dataset match regex used to screen the filenames </div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;     for matching datasets. </div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;     (default: `^.*\\.(h5|he5|nc4)(\\.bz2|\\.gz|\\.Z)?$`)</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160; -k: Keep the downloaded datafiles after the dmr++ file has been </div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;     created. Be careful! S3 buckets can be quite large!</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;Dependencies:</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;This script requires that:</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160; - The bes installation directory is on the PATH.</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160; - The AWS Commandline Tools are installed and on the path.</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160; - The AWS Commandline Tools have been configured for this user with</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;   AWS access_key_id and aws_secret_access_key that have adequate permissions</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;   to access the target AWS S3 bucket.</div></div><!-- fragment --><h3>example 1</h3>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ingest_s3bucket </div></div><!-- fragment --><p>In its simplest invocation, <code>ingest_s3bucket</code>'s defaults will cause it check for the file <code>./s3_cloudydap_data_files.txt</code>. (It looks for this file because the default bucket name is <code>cloudydap</code> and the software caches bucket information in the files named in the patterns <code>s3_BUCKETNAME_all_files.txt</code> <code>s3_BUCKETNAME_data_files.txt</code>. Changing the bucket name will change the name of the file information files accordingly). If the file is found, <code>ingest_s3bucket</code> will treat the 4th column of every line in <code>./s3_cloudydap_data_files.txt</code> as a relative path to an <code>hdf5</code>/<code>netcdf-4</code> file in the default bucket (<code>cloudydap</code>) for which a <code>dmr++</code> file is to be computed. By default the output tree will be placed in the current working directory. The base end point for the <code>dmr++</code> binary object will be set the URL of the S3 binary file that was used to create the <code><a href="https://s3.amazonaws.comdmr++">https://s3.amazonaws.comdmr++</a></code> file.</p>
<h3>example 2</h3>
<p>In this example we have <code>ingest_s3bucket</code> locate all the matching data files in the S3 bucket <code>opendap.scratch</code>, store the downloaded data files in <code>/tmp/s3_scratch</code>, and place the resulting dmr++ files in <code>/usr/share/hyrax</code>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ingest_s3bucket -v -f -b opendap.scratch -d /tmp/s3_scratch -t /usr/share/hyrax </div></div><!-- fragment --> <dl>
<dt><code>-v</code> </dt>
<dd><em>verbose mode</em> </dd>
<dt><code>-f</code> </dt>
<dd><em>Use the <code>find</code> command along with the regular expression to traverse the object names retrieved from S3 and locate all of the matching files. These file names saved in the file <code>./s3_BUCKETNAME_data_files.txt</code> to be reused or hand edited if needed.</em> </dd>
<dt><code>-v</code> </dt>
<dd><em>verbose mode</em> </dd>
<dt><code>-b opendap.scratch</code> </dt>
<dd><em>Sets the source S3 bucket name to <code>opendap.scratch</code></em> </dd>
<dt><code>-d /tmp/s3_scratch</code> </dt>
<dd><em>Sets the target directory for the data files downloaded from the S3 bucket to <code>/tmp/s3_scratch</code></em> </dd>
<dt><code>-t /usr/share/hyrax</code> </dt>
<dd><em>Sets the directory to which the dmr++ output tree will be written to: <code> /usr/share/hyrax</code>, the default data directry for Hyrax.</em> </dd>
</dl>
<h2>What To Do</h2>
<ol type="1">
<li>Determine the base URL of the hosting service (AWS S3, Google Cloud Store, Apache httpd, etc) you intend to utilize. For example in S3 you need to know the <em>bucket name</em> and the AWS S3 URL (<a href="https://s3.amazonaws.com">https://s3.amazonaws.com</a>)</li>
</ol>
<ol type="1">
<li>If you haven't already done so put your data into the hosting service space (And if you <em>do</em> have it locally don't remove it until the _dmr++_ process is completed!)</li>
</ol>
<ol type="1">
<li>Use the tools discussed below to make one or dmr++ files for your data (you'll need the bucket name and all that from previosuly)</li>
</ol>
<ol type="1">
<li>Place the _dmr++_ files, in any organization desired, into the BES.Catalog.catalog.RootDirectory tree.</li>
</ol>
<ol type="1">
<li>You can now access the remote data by navigating to the location of the _dmr++_ files and access them through the Data REquest Form or the DAP2 and DAP4 protocols.</li>
</ol>
<h1>Previously</h1>
<p>ChangeLog</p>
<p>5/25/18</p>
<ul>
<li>Added *.bescmd files for a number of new test files so that we can tell if the hdf5 handler can read these files. If it cannot, then it will be impossible to get a DMR file for input to build_dmrpp to build the DMR++ file for this code. The new test files were made using the mkChunkNewTypes.py script. jhrg</li>
</ul>
<p>4/3/19</p><ul>
<li>Renamed conf files to something less tedious, bes.hdf5.cf.conf(.in)</li>
<li>Removed bes.hdf5.cf.conf from git as it will now be built.</li>
<li>Created "check-local" and "clean-local" targets that cause the bes.hdf5.cf.conf gile to be built correctly for use with get_dmrpp.sh This all happens when running "make check" </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
