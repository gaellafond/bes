<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>bes: bes::DmrppMetadataStore Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bes
   &#160;<span id="projectnumber">Updated for version 3.20.8-314</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('de/d7d/classbes_1_1DmrppMetadataStore.html','../../');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d2/d58/classbes_1_1DmrppMetadataStore-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bes::DmrppMetadataStore Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Store the DAP DMR++ metadata responses.  
 <a href="../../de/d7d/classbes_1_1DmrppMetadataStore.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../df/d52/DmrppMetadataStore_8h_source.html">DmrppMetadataStore.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for bes::DmrppMetadataStore:</div>
<div class="dyncontent">
<div class="center"><img src="../../d6/ddc/classbes_1_1DmrppMetadataStore__coll__graph.png" border="0" usemap="#bes_1_1DmrppMetadataStore_coll__map" alt="Collaboration graph"/></div>
<map name="bes_1_1DmrppMetadataStore_coll__map" id="bes_1_1DmrppMetadataStore_coll__map">
<area shape="rect" id="node2" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html" title="Store the DAP metadata responses. " alt="" coords="101,448,294,1127"/>
<area shape="rect" id="node3" href="../../dd/d75/classBESFileLockingCache.html" title="Implementation of a caching mechanism for compressed data. " alt="" coords="5,147,200,385"/>
<area shape="rect" id="node4" href="../../d9/d76/classBESObj.html" title="top level BES object to house generic methods " alt="" coords="54,5,151,97"/>
<area shape="rect" id="node5" title="STL class. " alt="" coords="224,227,304,305"/>
<area shape="rect" id="node6" title="STL class. " alt="" coords="201,5,327,97"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db9/structbes_1_1DmrppMetadataStore_1_1StreamDMRpp.html">StreamDMRpp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hack use a DMR to write a DMR++ response. WIP.  <a href="../../d2/db9/structbes_1_1DmrppMetadataStore_1_1StreamDMRpp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a33de1af1511bf8cb6dd66f21b9604976"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33de1af1511bf8cb6dd66f21b9604976"></a>
typedef struct <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">MDSReadLock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MDSReadLock</b></td></tr>
<tr class="separator:a33de1af1511bf8cb6dd66f21b9604976"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1228235b231cbab0323d5bf34bbffafe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1228235b231cbab0323d5bf34bbffafe"></a>
virtual <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_dmrpp_response</b> (libdap::DMR *dmrpp, const std::string &amp;name)</td></tr>
<tr class="separator:a1228235b231cbab0323d5bf34bbffafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baf833605b9b117f37f18d442a0e9d2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html#a1baf833605b9b117f37f18d442a0e9d2">add_responses</a> (libdap::DMR *dmrpp, const std::string &amp;name)</td></tr>
<tr class="memdesc:a1baf833605b9b117f37f18d442a0e9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the DAP4 metadata responses using a DMR.  <a href="#a1baf833605b9b117f37f18d442a0e9d2">More...</a><br /></td></tr>
<tr class="separator:a1baf833605b9b117f37f18d442a0e9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1937b9c0ef4bdd6fa24a58c88afb65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#a8e1937b9c0ef4bdd6fa24a58c88afb65">cache_enabled</a> () const </td></tr>
<tr class="separator:a8e1937b9c0ef4bdd6fa24a58c88afb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441ebd5ab55997464c99acdb68c5b8d2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#a441ebd5ab55997464c99acdb68c5b8d2">cache_too_big</a> (unsigned long long current_size) const </td></tr>
<tr class="memdesc:a441ebd5ab55997464c99acdb68c5b8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">look at the cache size; is it too large? Look at the cache size and see if it is too big.  <a href="#a441ebd5ab55997464c99acdb68c5b8d2">More...</a><br /></td></tr>
<tr class="separator:a441ebd5ab55997464c99acdb68c5b8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e12d93d7fe5f5f03190f92362773050"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#a9e12d93d7fe5f5f03190f92362773050">create_and_lock</a> (const std::string &amp;target, int &amp;fd)</td></tr>
<tr class="memdesc:a9e12d93d7fe5f5f03190f92362773050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a file in the cache and lock it for write access.  <a href="#a9e12d93d7fe5f5f03190f92362773050">More...</a><br /></td></tr>
<tr class="separator:a9e12d93d7fe5f5f03190f92362773050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a1e37ad99b3e5a63945f94e1e3d934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#ad1a1e37ad99b3e5a63945f94e1e3d934">disable</a> ()</td></tr>
<tr class="memdesc:ad1a1e37ad99b3e5a63945f94e1e3d934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the cache.  <a href="#ad1a1e37ad99b3e5a63945f94e1e3d934">More...</a><br /></td></tr>
<tr class="separator:ad1a1e37ad99b3e5a63945f94e1e3d934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd053fcd8ceb24ba976f86dc8c95d7a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#afd053fcd8ceb24ba976f86dc8c95d7a9">dump</a> (std::ostream &amp;strm) const </td></tr>
<tr class="memdesc:afd053fcd8ceb24ba976f86dc8c95d7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">dumps information about this object  <a href="#afd053fcd8ceb24ba976f86dc8c95d7a9">More...</a><br /></td></tr>
<tr class="separator:afd053fcd8ceb24ba976f86dc8c95d7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f797d80ea5fd50d236f1f19d1c885cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#a8f797d80ea5fd50d236f1f19d1c885cf">enable</a> ()</td></tr>
<tr class="memdesc:a8f797d80ea5fd50d236f1f19d1c885cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the cache.  <a href="#a8f797d80ea5fd50d236f1f19d1c885cf">More...</a><br /></td></tr>
<tr class="separator:a8f797d80ea5fd50d236f1f19d1c885cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75f998ba8f95f88ba25624ff300f3ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#aa75f998ba8f95f88ba25624ff300f3ec">exclusive_to_shared_lock</a> (int fd)</td></tr>
<tr class="memdesc:aa75f998ba8f95f88ba25624ff300f3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from an exclusive lock to a shared lock.  <a href="#aa75f998ba8f95f88ba25624ff300f3ec">More...</a><br /></td></tr>
<tr class="separator:aa75f998ba8f95f88ba25624ff300f3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3d32e170d1337990d781ce8e8dd779"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#a5a3d32e170d1337990d781ce8e8dd779">get_cache_directory</a> ()</td></tr>
<tr class="separator:a5a3d32e170d1337990d781ce8e8dd779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5c91d47aeace35bd4fe77615d3eb91"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#afe5c91d47aeace35bd4fe77615d3eb91">get_cache_file_name</a> (const std::string &amp;src, <a class="el" href="../../d9/db9/classbool.html">bool</a> mangle=true)</td></tr>
<tr class="separator:afe5c91d47aeace35bd4fe77615d3eb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac337a4dd759097dfe5f9c5d328e6674c"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#ac337a4dd759097dfe5f9c5d328e6674c">get_cache_file_prefix</a> ()</td></tr>
<tr class="separator:ac337a4dd759097dfe5f9c5d328e6674c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42464f4610216aec307fb3788d723a9"><td class="memItemLeft" align="right" valign="top">virtual time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#ae42464f4610216aec307fb3788d723a9">get_cache_lmt</a> (const std::string &amp;fileName, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:ae42464f4610216aec307fb3788d723a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last modified time for the cached object file.  <a href="#ae42464f4610216aec307fb3788d723a9">More...</a><br /></td></tr>
<tr class="separator:ae42464f4610216aec307fb3788d723a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d19ed9a8c96bedf8422316b3e8fafa"><td class="memItemLeft" align="right" valign="top">virtual unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#a20d19ed9a8c96bedf8422316b3e8fafa">get_cache_size</a> ()</td></tr>
<tr class="memdesc:a20d19ed9a8c96bedf8422316b3e8fafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache size.  <a href="#a20d19ed9a8c96bedf8422316b3e8fafa">More...</a><br /></td></tr>
<tr class="separator:a20d19ed9a8c96bedf8422316b3e8fafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b47875a2855d0fbc18edc2117d6cc63"><td class="memItemLeft" align="right" valign="top">virtual libdap::DDS *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a0b47875a2855d0fbc18edc2117d6cc63">get_dds_object</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a0b47875a2855d0fbc18edc2117d6cc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a DDS object from the cached Response.  <a href="#a0b47875a2855d0fbc18edc2117d6cc63">More...</a><br /></td></tr>
<tr class="separator:a0b47875a2855d0fbc18edc2117d6cc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee9df3e909ff08dd18aa660b89fe73d"><td class="memItemLeft" align="right" valign="top">virtual libdap::DMR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html#a4ee9df3e909ff08dd18aa660b89fe73d">get_dmr_object</a> (const string &amp;name)</td></tr>
<tr class="memdesc:a4ee9df3e909ff08dd18aa660b89fe73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the DMR response to build a DMR with Dmrpp Types.  <a href="#a4ee9df3e909ff08dd18aa660b89fe73d">More...</a><br /></td></tr>
<tr class="separator:a4ee9df3e909ff08dd18aa660b89fe73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6451ee441056e0581be4e79952a13f"><td class="memItemLeft" align="right" valign="top">virtual libdap::DMR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#adf6451ee441056e0581be4e79952a13f">get_dmr_object</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:adf6451ee441056e0581be4e79952a13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a DMR object from the cached Response.  <a href="#adf6451ee441056e0581be4e79952a13f">More...</a><br /></td></tr>
<tr class="separator:adf6451ee441056e0581be4e79952a13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc0558a65b6f0fe5c6dd6d340ff1f80"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../db/d4d/classdmrpp_1_1DMRpp.html">dmrpp::DMRpp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html#aedc0558a65b6f0fe5c6dd6d340ff1f80">get_dmrpp_object</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aedc0558a65b6f0fe5c6dd6d340ff1f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a DMR++ object from the cached Response.  <a href="#aedc0558a65b6f0fe5c6dd6d340ff1f80">More...</a><br /></td></tr>
<tr class="separator:aedc0558a65b6f0fe5c6dd6d340ff1f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0447cb98e124a3deb742ae94c87f0b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0447cb98e124a3deb742ae94c87f0b5"></a>
virtual <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_exclusive_lock</b> (const std::string &amp;target, int &amp;fd)</td></tr>
<tr class="separator:ad0447cb98e124a3deb742ae94c87f0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6a817d4bfc6756547a9b282c6405c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc6a817d4bfc6756547a9b282c6405c5"></a>
virtual <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_exclusive_lock_nb</b> (const std::string &amp;target, int &amp;fd)</td></tr>
<tr class="separator:adc6a817d4bfc6756547a9b282c6405c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ae66ea9b3931933f3f4e02562a8d04"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#aa9ae66ea9b3931933f3f4e02562a8d04">get_read_lock</a> (const std::string &amp;target, int &amp;fd)</td></tr>
<tr class="memdesc:aa9ae66ea9b3931933f3f4e02562a8d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read-only lock on the file if it exists.  <a href="#aa9ae66ea9b3931933f3f4e02562a8d04">More...</a><br /></td></tr>
<tr class="separator:aa9ae66ea9b3931933f3f4e02562a8d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500a4ca2539d42c5aa7c9a702f0647b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#a500a4ca2539d42c5aa7c9a702f0647b8">initialize</a> (const std::string &amp;cache_dir, const std::string &amp;prefix, unsigned long long size)</td></tr>
<tr class="memdesc:a500a4ca2539d42c5aa7c9a702f0647b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an instance of FileLockingCache.  <a href="#a500a4ca2539d42c5aa7c9a702f0647b8">More...</a><br /></td></tr>
<tr class="separator:a500a4ca2539d42c5aa7c9a702f0647b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6ab8066b0cd04b49dccfb9612bf139"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#aed6ab8066b0cd04b49dccfb9612bf139">is_available_helper</a> (const std::string &amp;realName, const std::string &amp;relativeName, const std::string &amp;fileType, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:aed6ab8066b0cd04b49dccfb9612bf139"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function that checks if last modified time is greater than cached file  <a href="#aed6ab8066b0cd04b49dccfb9612bf139">More...</a><br /></td></tr>
<tr class="separator:aed6ab8066b0cd04b49dccfb9612bf139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cf29d8fdac3b7e8bcb107b60e8cb40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">MDSReadLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#ae7cf29d8fdac3b7e8bcb107b60e8cb40">is_das_available</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ae7cf29d8fdac3b7e8bcb107b60e8cb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the DAS response for.  <a href="#ae7cf29d8fdac3b7e8bcb107b60e8cb40">More...</a><br /></td></tr>
<tr class="separator:ae7cf29d8fdac3b7e8bcb107b60e8cb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63fbb60bae38249f2bd7903d484f785"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae63fbb60bae38249f2bd7903d484f785"></a>
virtual <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">MDSReadLock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_das_available</b> (const <a class="el" href="../../d2/d74/classBESContainer.html">BESContainer</a> &amp;container)</td></tr>
<tr class="separator:ae63fbb60bae38249f2bd7903d484f785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9075d8a40a9a53ed82e78cc8685fe2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">MDSReadLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#acf9075d8a40a9a53ed82e78cc8685fe2">is_dds_available</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:acf9075d8a40a9a53ed82e78cc8685fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the DDS response for.  <a href="#acf9075d8a40a9a53ed82e78cc8685fe2">More...</a><br /></td></tr>
<tr class="separator:acf9075d8a40a9a53ed82e78cc8685fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc0e105d6216fc7995f418380ffd310"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">MDSReadLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#aedc0e105d6216fc7995f418380ffd310">is_dds_available</a> (const <a class="el" href="../../d2/d74/classBESContainer.html">BESContainer</a> &amp;container)</td></tr>
<tr class="memdesc:aedc0e105d6216fc7995f418380ffd310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the DDS response for.  <a href="#aedc0e105d6216fc7995f418380ffd310">More...</a><br /></td></tr>
<tr class="separator:aedc0e105d6216fc7995f418380ffd310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6204dcd40cf3c94efdcf82bc6c08076"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">MDSReadLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#ae6204dcd40cf3c94efdcf82bc6c08076">is_dmr_available</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ae6204dcd40cf3c94efdcf82bc6c08076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the DMR response for.  <a href="#ae6204dcd40cf3c94efdcf82bc6c08076">More...</a><br /></td></tr>
<tr class="separator:ae6204dcd40cf3c94efdcf82bc6c08076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09351a7e6992fc3bfafbcda15d409ed2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09351a7e6992fc3bfafbcda15d409ed2"></a>
virtual <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">MDSReadLock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_dmr_available</b> (const <a class="el" href="../../d2/d74/classBESContainer.html">BESContainer</a> &amp;container)</td></tr>
<tr class="separator:a09351a7e6992fc3bfafbcda15d409ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1f11b205f83927f5ebc819ef6bf50b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c1f11b205f83927f5ebc819ef6bf50b"></a>
virtual <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">MDSReadLock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_dmr_available</b> (const std::string &amp;realName, const std::string &amp;relativeName, const std::string &amp;fileType)</td></tr>
<tr class="separator:a8c1f11b205f83927f5ebc819ef6bf50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21a47ed48b30dec2238e7ac0d1878c0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">MDSReadLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#ac21a47ed48b30dec2238e7ac0d1878c0">is_dmrpp_available</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ac21a47ed48b30dec2238e7ac0d1878c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the DMR++ response for.  <a href="#ac21a47ed48b30dec2238e7ac0d1878c0">More...</a><br /></td></tr>
<tr class="separator:ac21a47ed48b30dec2238e7ac0d1878c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa03b1dcf7ed3fe12ebbe5f5b53e66b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa03b1dcf7ed3fe12ebbe5f5b53e66b3"></a>
virtual <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">MDSReadLock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_dmrpp_available</b> (const <a class="el" href="../../d2/d74/classBESContainer.html">BESContainer</a> &amp;container)</td></tr>
<tr class="separator:afa03b1dcf7ed3fe12ebbe5f5b53e66b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2dd8d01a9c4cafdb28d2a7c1490fe89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#ae2dd8d01a9c4cafdb28d2a7c1490fe89">is_unlimited</a> () const </td></tr>
<tr class="memdesc:ae2dd8d01a9c4cafdb28d2a7c1490fe89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this cache allowed to store as much as it wants?  <a href="#ae2dd8d01a9c4cafdb28d2a7c1490fe89">More...</a><br /></td></tr>
<tr class="separator:ae2dd8d01a9c4cafdb28d2a7c1490fe89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac962a660afcac0159cae6d56f739a74c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#ac962a660afcac0159cae6d56f739a74c">lock_cache_read</a> ()</td></tr>
<tr class="separator:ac962a660afcac0159cae6d56f739a74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662d290c14ded24e4038732c5d2667b1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#a662d290c14ded24e4038732c5d2667b1">lock_cache_write</a> ()</td></tr>
<tr class="separator:a662d290c14ded24e4038732c5d2667b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d57ea1ffcb98b75cfb71c81d52ed3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86d57ea1ffcb98b75cfb71c81d52ed3e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>parse_das_from_mds</b> (libdap::DAS *das, const std::string &amp;name)</td></tr>
<tr class="separator:a86d57ea1ffcb98b75cfb71c81d52ed3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af097935543e9f85317b6751ac9d20a88"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#af097935543e9f85317b6751ac9d20a88">purge_file</a> (const std::string &amp;file)</td></tr>
<tr class="memdesc:af097935543e9f85317b6751ac9d20a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge a single file from the cache.  <a href="#af097935543e9f85317b6751ac9d20a88">More...</a><br /></td></tr>
<tr class="separator:af097935543e9f85317b6751ac9d20a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba0172669af0bfa54c6ca4a5bc729ad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a4ba0172669af0bfa54c6ca4a5bc729ad">remove_responses</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a4ba0172669af0bfa54c6ca4a5bc729ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all cached responses and objects for a granule.  <a href="#a4ba0172669af0bfa54c6ca4a5bc729ad">More...</a><br /></td></tr>
<tr class="separator:a4ba0172669af0bfa54c6ca4a5bc729ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5777955384b133127a2518f44ea28444"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#a5777955384b133127a2518f44ea28444">unlock_and_close</a> (const std::string &amp;target)</td></tr>
<tr class="separator:a5777955384b133127a2518f44ea28444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a70fdaa70577bd545eb842015bb85b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#a1a70fdaa70577bd545eb842015bb85b8">unlock_cache</a> ()</td></tr>
<tr class="separator:a1a70fdaa70577bd545eb842015bb85b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7797d9ecb3d4daf0efc9e4ca0a36ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#afd7797d9ecb3d4daf0efc9e4ca0a36ce">update_and_purge</a> (const std::string &amp;new_file)</td></tr>
<tr class="memdesc:afd7797d9ecb3d4daf0efc9e4ca0a36ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge files from the cache.  <a href="#afd7797d9ecb3d4daf0efc9e4ca0a36ce">More...</a><br /></td></tr>
<tr class="separator:afd7797d9ecb3d4daf0efc9e4ca0a36ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf293b1c39103e9d6d0fcb88edabe6a"><td class="memItemLeft" align="right" valign="top">virtual unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#a5bf293b1c39103e9d6d0fcb88edabe6a">update_cache_info</a> (const std::string &amp;target)</td></tr>
<tr class="memdesc:a5bf293b1c39103e9d6d0fcb88edabe6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the cache info file to include 'target'.  <a href="#a5bf293b1c39103e9d6d0fcb88edabe6a">More...</a><br /></td></tr>
<tr class="separator:a5bf293b1c39103e9d6d0fcb88edabe6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bf1be061daa2001bef3aa923e558f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#ab6bf1be061daa2001bef3aa923e558f7">write_das_response</a> (const std::string &amp;name, std::ostream &amp;os)</td></tr>
<tr class="memdesc:ab6bf1be061daa2001bef3aa923e558f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the stored DAS response to a stream.  <a href="#ab6bf1be061daa2001bef3aa923e558f7">More...</a><br /></td></tr>
<tr class="separator:ab6bf1be061daa2001bef3aa923e558f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc23c9c17aefe24166186372b18c4d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a4fc23c9c17aefe24166186372b18c4d8">write_dds_response</a> (const std::string &amp;name, std::ostream &amp;os)</td></tr>
<tr class="memdesc:a4fc23c9c17aefe24166186372b18c4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the stored DDS response to a stream.  <a href="#a4fc23c9c17aefe24166186372b18c4d8">More...</a><br /></td></tr>
<tr class="separator:a4fc23c9c17aefe24166186372b18c4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e641d7d6f51d95196bec3b413f9bd17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a1e641d7d6f51d95196bec3b413f9bd17">write_dmr_response</a> (const std::string &amp;name, std::ostream &amp;os)</td></tr>
<tr class="memdesc:a1e641d7d6f51d95196bec3b413f9bd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the stored DMR response to a stream.  <a href="#a1e641d7d6f51d95196bec3b413f9bd17">More...</a><br /></td></tr>
<tr class="separator:a1e641d7d6f51d95196bec3b413f9bd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f19d5509fba49757b1c342b2314269"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#af1f19d5509fba49757b1c342b2314269">write_dmrpp_response</a> (const std::string &amp;name, std::ostream &amp;os)</td></tr>
<tr class="memdesc:af1f19d5509fba49757b1c342b2314269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the stored DMR++ response to a stream.  <a href="#af1f19d5509fba49757b1c342b2314269">More...</a><br /></td></tr>
<tr class="separator:af1f19d5509fba49757b1c342b2314269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Add responses to the GlobalMetadataStore</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods use a DDS or DMR object to generate the DDS, DAS and DMR responses for DAP (2 and 4). They store those in the MDS and then update the MDS ledger file with the operation (add), the kind of object used to build the responses (DDS or DMR), name of the granule and hashes/names for each of the three files in the MDS that hold the responses.</p>
<p>If verbose logging is on, the bes log also will hold information about the operation. If there is an error, that will always be recorded in the bes log. </p>
</div></td></tr>
<tr class="memitem:aef4a05b76c7bc491fac1804d8bb9ad56"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#aef4a05b76c7bc491fac1804d8bb9ad56">add_responses</a> (libdap::DDS *dds, const std::string &amp;name)</td></tr>
<tr class="memdesc:aef4a05b76c7bc491fac1804d8bb9ad56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the DAP2 metadata responses using a DDS.  <a href="#aef4a05b76c7bc491fac1804d8bb9ad56">More...</a><br /></td></tr>
<tr class="separator:aef4a05b76c7bc491fac1804d8bb9ad56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abf78b713bf1230d3a93bd078be0ec417"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d75/classBESFileLockingCache.html#abf78b713bf1230d3a93bd078be0ec417">dir_exists</a> (const std::string &amp;dir)</td></tr>
<tr class="separator:abf78b713bf1230d3a93bd078be0ec417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get an instance of DmrppMetadataStore</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>There are two ways to get an instance of <a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html" title="Store the DAP DMR++ metadata responses. ">DmrppMetadataStore</a> singleton.</p>
<dl class="section note"><dt>Note</dt><dd>If the cache_dir parameter is the empty string, <a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html#a5488089ce927ab3aeb45dfcb78411897">get_instance()</a> will return null for the pointer to the singleton and caching is disabled. This means that if the cache directory is not set in the bes.conf file(s), then the cache will be disabled. If the cache directory is given (or set in bes.conf) but the prefix or size is not, that's an error. If the directory is named but does not exist, it will be made. If the BES cannot make it, then an error will be signaled.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html" title="Store the DAP DMR++ metadata responses. ">DmrppMetadataStore</a> object; null if the cache is disabled. </dd></dl>
</div></td></tr>
<tr class="memitem:a61588e51b11f6bd309cfae31c6463bff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html">DmrppMetadataStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html#a61588e51b11f6bd309cfae31c6463bff">get_instance</a> (const std::string &amp;cache_dir, const std::string &amp;prefix, unsigned long long size)</td></tr>
<tr class="memdesc:a61588e51b11f6bd309cfae31c6463bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an instance of the <a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html" title="Store the DAP DMR++ metadata responses. ">DmrppMetadataStore</a> object.  <a href="#a61588e51b11f6bd309cfae31c6463bff">More...</a><br /></td></tr>
<tr class="separator:a61588e51b11f6bd309cfae31c6463bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5488089ce927ab3aeb45dfcb78411897"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html">DmrppMetadataStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html#a5488089ce927ab3aeb45dfcb78411897">get_instance</a> ()</td></tr>
<tr class="separator:a5488089ce927ab3aeb45dfcb78411897"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0112a1ee3f96417202b396c52c944194"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0112a1ee3f96417202b396c52c944194"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DmrppMetadataStore</b> (const <a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html">DmrppMetadataStore</a> &amp;src)</td></tr>
<tr class="separator:a0112a1ee3f96417202b396c52c944194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93cffa5f353a6565140af287f210b4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af93cffa5f353a6565140af287f210b4e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DmrppMetadataStore</b> (const std::string &amp;cache_dir, const std::string &amp;prefix, unsigned long long size)</td></tr>
<tr class="separator:af93cffa5f353a6565140af287f210b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30400e4443560c5ab008401b003cbe0b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a30400e4443560c5ab008401b003cbe0b">get_hash</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a30400e4443560c5ab008401b003cbe0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dc85b5343374daa7606de7b8aec69c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">MDSReadLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#ae1dc85b5343374daa7606de7b8aec69c">get_read_lock_helper</a> (const std::string &amp;name, const std::string &amp;suffix, const std::string &amp;object_name)</td></tr>
<tr class="separator:ae1dc85b5343374daa7606de7b8aec69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f94ba8d66305a2eb9b9da379373fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a58f94ba8d66305a2eb9b9da379373fa9">initialize</a> ()</td></tr>
<tr class="memdesc:a58f94ba8d66305a2eb9b9da379373fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the ledger using LEDGER_KEY and LOCAL_TIME_KEY.  <a href="#a58f94ba8d66305a2eb9b9da379373fa9">More...</a><br /></td></tr>
<tr class="separator:a58f94ba8d66305a2eb9b9da379373fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f813db1d70c89a09ea98a33e34cc57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#ac0f813db1d70c89a09ea98a33e34cc57">remove_response_helper</a> (const std::string &amp;name, const std::string &amp;suffix, const std::string &amp;object_name)</td></tr>
<tr class="separator:ac0f813db1d70c89a09ea98a33e34cc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e5d3fb5124799535bc5c7dfcf8008e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a96e5d3fb5124799535bc5c7dfcf8008e">store_dap_response</a> (<a class="el" href="../../d8/d0a/structbes_1_1GlobalMetadataStore_1_1StreamDAP.html">StreamDAP</a> &amp;writer, const std::string &amp;key, const std::string &amp;name, const std::string &amp;response_name)</td></tr>
<tr class="separator:a96e5d3fb5124799535bc5c7dfcf8008e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e416cb60cae7c0f67d1811322e7ab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a86e416cb60cae7c0f67d1811322e7ab0">write_ledger</a> ()</td></tr>
<tr class="separator:a86e416cb60cae7c0f67d1811322e7ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">write_response_helper</div></td></tr>
<tr class="memitem:a2eea0ad3d494d430d84c94509d91ae54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a2eea0ad3d494d430d84c94509d91ae54">write_response_helper</a> (const std::string &amp;name, std::ostream &amp;os, const std::string &amp;suffix, const std::string &amp;object_name)</td></tr>
<tr class="separator:a2eea0ad3d494d430d84c94509d91ae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a743c4026bbf299344def17376bc56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a85a743c4026bbf299344def17376bc56">write_response_helper</a> (const std::string &amp;name, std::ostream &amp;os, const std::string &amp;suffix, const std::string &amp;xml_base, const std::string &amp;object_name)</td></tr>
<tr class="memdesc:a85a743c4026bbf299344def17376bc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version looks at the first few bytes and substitutes a new value for xml:base.  <a href="#a85a743c4026bbf299344def17376bc56">More...</a><br /></td></tr>
<tr class="separator:a85a743c4026bbf299344def17376bc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a5b0b17aad809cdc5b931335f513af171"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b0b17aad809cdc5b931335f513af171"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>get_cache_dir_from_config</b> ()</td></tr>
<tr class="separator:a5b0b17aad809cdc5b931335f513af171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cccaff1bdc81dae64677ee1298d7e2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cccaff1bdc81dae64677ee1298d7e2c"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>get_cache_prefix_from_config</b> ()</td></tr>
<tr class="separator:a6cccaff1bdc81dae64677ee1298d7e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e805678a96b4360876e08a44379bac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19e805678a96b4360876e08a44379bac"></a>
static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>get_cache_size_from_config</b> ()</td></tr>
<tr class="separator:a19e805678a96b4360876e08a44379bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedb248a891f302e279837afd667ed86"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#aaedb248a891f302e279837afd667ed86">insert_xml_base</a> (int fd, std::ostream &amp;os, const std::string &amp;xml_base)</td></tr>
<tr class="memdesc:aaedb248a891f302e279837afd667ed86"><td class="mdescLeft">&#160;</td><td class="mdescRight">like <a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a4276dbea6b47169a7a3f5877228d74ef">transfer_bytes()</a>, but adds the xml:base attribute to the DMR/++  <a href="#aaedb248a891f302e279837afd667ed86">More...</a><br /></td></tr>
<tr class="separator:aaedb248a891f302e279837afd667ed86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4276dbea6b47169a7a3f5877228d74ef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a4276dbea6b47169a7a3f5877228d74ef">transfer_bytes</a> (int fd, std::ostream &amp;os)</td></tr>
<tr class="separator:a4276dbea6b47169a7a3f5877228d74ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab27cba1772cf043a0c9949ea2b343a17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab27cba1772cf043a0c9949ea2b343a17"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>d_ledger_entry</b></td></tr>
<tr class="separator:ab27cba1772cf043a0c9949ea2b343a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2f6a9ae26198d6fd187d7f3ce147a636"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f6a9ae26198d6fd187d7f3ce147a636"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DmrppMetadataStoreTest</b></td></tr>
<tr class="separator:a2f6a9ae26198d6fd187d7f3ce147a636"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Store the DAP DMR++ metadata responses. </p>
<p>Provide a way to add DMR++ responses to the Global MDS (see <a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html" title="Store the DAP metadata responses. ">GlobalMetadataStore</a>). This specialization of the MDS adds the ability to add DMR++ responses and extract DMR++ objects. This code is accessible only in the DMR++ handler, while the Global MDS is available anywhere (it's defined in bes/dap). Because the BES framework needs to determine if DMR++ responses are included in the MDS, the Global MDS class has methods to test for that and to 'write' that response.</p>
<p>In order for the BES to work with a DMR++ <em>object</em>, however, it will need to transfer control to the DMR++ Handler and, if it is going to use the response in the MDS, use this specialization to read from the MDS.</p>
<p>The class is implemented as a singleton; use the <a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html#a5488089ce927ab3aeb45dfcb78411897">get_instance()</a> methods to get an instance of the DMR++ metadata store. It uses <em>the same</em> configuration parameters as the Global MDS, so if the defaults are uses, both the singleton Global MDS and this DMR++ MDS will be using the same directory, file prefix and size limit.</p>
<p>BES Keys used:</p><ul>
<li><em>DAP.GlobalMetadataStore.path</em>: store root directory (assumes the store is using a POSIX file system)</li>
<li><em>DAP.GlobalMetadataStore.prefix</em>: prefix for the names of items in the store</li>
<li><em>DAP.GlobalMetadataStore.size</em>: Maximum size of the store. Zero indicates unlimited size.</li>
<li><em>DAP.GlobalMetadataStore.ledger</em>: Name of the ledger. A relative pathname. will be interpreted as relative to the directory where the BES was started. The default name mds_ledger.txt</li>
<li><em>BES.LogTimeLocal</em>: Use local or GMT time for the ledger entries; default is to use GMT</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>jhrg </dd></dl>

<p>Definition at line <a class="el" href="../../df/d52/DmrppMetadataStore_8h_source.html#l00083">83</a> of file <a class="el" href="../../df/d52/DmrppMetadataStore_8h_source.html">DmrppMetadataStore.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1baf833605b9b117f37f18d442a0e9d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> DmrppMetadataStore::add_responses </td>
          <td>(</td>
          <td class="paramtype">libdap::DMR *&#160;</td>
          <td class="paramname"><em>dmrpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the DAP4 metadata responses using a DMR. </p>
<p>This method adds only the DMR unless the code was compiled with the symbol SYMETRIC_ADD_RESPONSES defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The granule name or identifier </td></tr>
    <tr><td class="paramname">dmr</td><td>A DMR built from the granule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all of the cache/store entry was written, False if any could not be written. </dd></dl>

<p>Reimplemented from <a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a98b8bbe3fc3c1c89f806e44589853a05">bes::GlobalMetadataStore</a>.</p>

<p>Definition at line <a class="el" href="../../d1/de4/DmrppMetadataStore_8cc_source.html#l00196">196</a> of file <a class="el" href="../../d1/de4/DmrppMetadataStore_8cc_source.html">DmrppMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aef4a05b76c7bc491fac1804d8bb9ad56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> GlobalMetadataStore::add_responses </td>
          <td>(</td>
          <td class="paramtype">libdap::DDS *&#160;</td>
          <td class="paramname"><em>dds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the DAP2 metadata responses using a DDS. </p>
<p>This method adds only the DDS and DAS unless the code was compiled with the symbol SYMETRIC_ADD_RESPONSES defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The granule name or identifier </td></tr>
    <tr><td class="paramname">dds</td><td>A DDS built from the granule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all of the cache/store entries were written, False if any could not be written. </dd></dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00647">647</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8e1937b9c0ef4bdd6fa24a58c88afb65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> BESFileLockingCache::cache_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Is this cache enabled? </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d28/BESFileLockingCache_8h_source.html#l00198">198</a> of file <a class="el" href="../../d5/d28/BESFileLockingCache_8h_source.html">BESFileLockingCache.h</a>.</p>

</div>
</div>
<a class="anchor" id="a441ebd5ab55997464c99acdb68c5b8d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> BESFileLockingCache::cache_too_big </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>current_size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>look at the cache size; is it too large? Look at the cache size and see if it is too big. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the size is too big, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00772">772</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9e12d93d7fe5f5f03190f92362773050"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> BESFileLockingCache::create_and_lock </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a file in the cache and lock it for write access. </p>
<p>If the file does not exist, make it, open it for read-write access and get an exclusive lock on it. The locking operation blocks, although that should never happen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The name of the file to make/open/lock </td></tr>
    <tr><td class="paramname">fd</td><td>Value-result param that holds the file descriptor of the opened file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation was successful, false otherwise. This method will return false if the file already existed (the file won't be locked and the descriptor reference is undefined - but likely -1).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">BESBESInternalErroror</td><td>if any error except EEXIST is returned by open(2) or if fcntl(2) returns an error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00592">592</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="abf78b713bf1230d3a93bd078be0ec417"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> BESFileLockingCache::dir_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does the directory exist?</p>
<dl class="section note"><dt>Note</dt><dd>This is a static method, so it can be called from other static methods like those that build instances of singletons.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>The pathname to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the directory exists, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l01129">1129</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad1a1e37ad99b3e5a63945f94e1e3d934"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BESFileLockingCache::disable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable the cache. </p>

<p>Definition at line <a class="el" href="../../d5/d28/BESFileLockingCache_8h_source.html#l00204">204</a> of file <a class="el" href="../../d5/d28/BESFileLockingCache_8h_source.html">BESFileLockingCache.h</a>.</p>

</div>
</div>
<a class="anchor" id="afd053fcd8ceb24ba976f86dc8c95d7a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BESFileLockingCache::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>strm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dumps information about this object </p>
<p>Displays the pointer value of this instance along with information about this cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>C++ i/o stream to dump the information to </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="../../d9/d76/classBESObj.html#a824f67aad3882f72bb52abf9967584ed">BESObj</a>.</p>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l01144">1144</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8f797d80ea5fd50d236f1f19d1c885cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BESFileLockingCache::enable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable the cache. </p>

<p>Definition at line <a class="el" href="../../d5/d28/BESFileLockingCache_8h_source.html#l00210">210</a> of file <a class="el" href="../../d5/d28/BESFileLockingCache_8h_source.html">BESFileLockingCache.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa75f998ba8f95f88ba25624ff300f3ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BESFileLockingCache::exclusive_to_shared_lock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer from an exclusive lock to a shared lock. </p>
<p>If the file has an exclusive write lock on it, change that to a shared read lock. This is an atomic operation. If the call to fcntl(2) is protected by locking the cache, a dead lock will result given typical use of this class. This method exists to help with the situation where one process has the cache locked and is blocking on a shared read lock for a file that a second process has locked exclusively (for writing). By changing the exclusive lock to a shared lock, the first process can get its shared lock and then release the cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor that is exclusively locked and which, on exit, will have a shared lock. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00622">622</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5a3d32e170d1337990d781ce8e8dd779"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string BESFileLockingCache::get_cache_directory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The directory used for the an instance of <a class="el" href="../../dd/d75/classBESFileLockingCache.html" title="Implementation of a caching mechanism for compressed data. ">BESFileLockingCache</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d28/BESFileLockingCache_8h_source.html#l00188">188</a> of file <a class="el" href="../../d5/d28/BESFileLockingCache_8h_source.html">BESFileLockingCache.h</a>.</p>

</div>
</div>
<a class="anchor" id="afe5c91d47aeace35bd4fe77615d3eb91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string BESFileLockingCache::get_cache_file_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>mangle</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the fully qualified file system path name for the cache file associated with this particular cache resource.</p>
<dl class="section note"><dt>Note</dt><dd>How names are mangled: ALl occurrences of the characters '&lt;', '&gt;', '=', ',', '/', '(', ')', '"', ''', ':', '?', and ' ' with the '#' character.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source name to cache </td></tr>
    <tr><td class="paramname">mangle</td><td>If True, assume the name is a file pathname and mangle it. If false, do not mangle the name (assume the caller has sent a suitable string) but do turn the string into a pathname located in the cache directory with the cache prefix. The 'mangle' param is true by default. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="../../d1/d11/classhttp_1_1HttpCache.html#a36408800309a6e92a81c564d46602081">http::HttpCache</a>, and <a class="el" href="../../d8/d0e/classBESUncompressCache.html#a859b055b41679ee217e2653a117b93ee">BESUncompressCache</a>.</p>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00444">444</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac337a4dd759097dfe5f9c5d328e6674c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string BESFileLockingCache::get_cache_file_prefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The prefix used for items in an instance of <a class="el" href="../../dd/d75/classBESFileLockingCache.html" title="Implementation of a caching mechanism for compressed data. ">BESFileLockingCache</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d28/BESFileLockingCache_8h_source.html#l00182">182</a> of file <a class="el" href="../../d5/d28/BESFileLockingCache_8h_source.html">BESFileLockingCache.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae42464f4610216aec307fb3788d723a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t GlobalMetadataStore::get_cache_lmt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last modified time for the cached object file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>- name of the object </td></tr>
    <tr><td class="paramname">suffix</td><td>- suffix of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last modified time. </dd></dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00999">999</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a20d19ed9a8c96bedf8422316b3e8fafa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long BESFileLockingCache::get_cache_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the cache size. </p>
<p>Read the size information from the cache info file and return it. This methods locks the cache.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the cache. </dd></dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00784">784</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0b47875a2855d0fbc18edc2117d6cc63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DDS * GlobalMetadataStore::get_dds_object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a DDS object from the cached Response. </p>
<p>Read the DDS and DAS responses, build a DDS using their information and return the binary DDS response. The variables are built using the default <a class="el" href="../../d4/d0c/classBaseTypeFactory.html">BaseTypeFactory</a> but the DDS object has the factory set to null when it is returned. The DDS is 'loaded' with attribute information as well, so it can be used to return the DDX response.</p>
<dl class="section note"><dt>Note</dt><dd>This method uses temporary files to hold the responses and then parses them to build the DDS object</dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000003">Todo:</a></b></dt><dd>If/When the DDS can be serialized, we should be able to replace this implementation with something far better - and something that can include information in specialized BaseTypes and DDS classes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Path to the dataset, relative to the BES data root directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the DDS object; the caller must delete this object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d9/d82/classBESInternalError.html" title="exception thrown if internal error encountered ">BESInternalError</a></td><td>is thrown if <ul>
<li>name does not have a cached DDS or DAS response. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l01250">1250</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a4ee9df3e909ff08dd18aa660b89fe73d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DMR * DmrppMetadataStore::get_dmr_object </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the DMR response to build a DMR with Dmrpp Types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The pathname to the dataset, relative to the BES data root directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A DMRpp using a pointer to the base class. </dd></dl>

<p>Definition at line <a class="el" href="../../d1/de4/DmrppMetadataStore_8cc_source.html#l00242">242</a> of file <a class="el" href="../../d1/de4/DmrppMetadataStore_8cc_source.html">DmrppMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="adf6451ee441056e0581be4e79952a13f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DMR * GlobalMetadataStore::get_dmr_object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a DMR object from the cached Response. </p>
<p>Read and parse a DMR response , building a binary DMR object. The object is returned with a null factory. The variables are built using the default DAP4 type factory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the DMR object; the caller must delete this object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d9/d82/classBESInternalError.html" title="exception thrown if internal error encountered ">BESInternalError</a></td><td>is thrown if <ul>
<li>name does not have a cached DMR response. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l01212">1212</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aedc0558a65b6f0fe5c6dd6d340ff1f80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d4d/classdmrpp_1_1DMRpp.html">DMRpp</a> * DmrppMetadataStore::get_dmrpp_object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a DMR++ object from the cached Response. </p>
<p>Read and parse a DMR++ response , building a binary DMR++ object. The object is returned with a null factory. The variables are built using DmrppTypeFactory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the DMR object; the caller must delete this object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d9/d82/classBESInternalError.html" title="exception thrown if internal error encountered ">BESInternalError</a></td><td>is thrown if <ul>
<li>name does not have a cached DMR response. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d1/de4/DmrppMetadataStore_8cc_source.html#l00274">274</a> of file <a class="el" href="../../d1/de4/DmrppMetadataStore_8cc_source.html">DmrppMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a30400e4443560c5ab008401b003cbe0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string GlobalMetadataStore::get_hash </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the SHA256 hash for the item name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The SHA256 hash of the name. </dd></dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00482">482</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a61588e51b11f6bd309cfae31c6463bff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html">DmrppMetadataStore</a> * DmrppMetadataStore::get_instance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cache_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an instance of the <a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html" title="Store the DAP DMR++ metadata responses. ">DmrppMetadataStore</a> object. </p>
<p>This class is a singleton, so the first call to any of two '<a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html#a5488089ce927ab3aeb45dfcb78411897">get_instance()</a>' methods makes an instance and subsequent calls return a pointer to that instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_dir_key</td><td>Key to use to get the value of the cache directory. If this is the empty string, return null right away. </td></tr>
    <tr><td class="paramname">prefix_key</td><td>Key for the item/file prefix. Each item added to the cache uses this as a prefix so cached items can be easily identified when the same directory is used for several caches or /tmp is used for the cache. </td></tr>
    <tr><td class="paramname">size_key</td><td>The maximum size of the data stored in the cache, in megabytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html" title="Store the DAP DMR++ metadata responses. ">DmrppMetadataStore</a> object. If the cache is disabled, then the pointer returned will be null and the cache will be marked as not enabled. Subsequent calls will return immediately. </dd></dl>

<p>Definition at line <a class="el" href="../../d1/de4/DmrppMetadataStore_8cc_source.html#l00107">107</a> of file <a class="el" href="../../d1/de4/DmrppMetadataStore_8cc_source.html">DmrppMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5488089ce927ab3aeb45dfcb78411897"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html">DmrppMetadataStore</a> * DmrppMetadataStore::get_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an instance of the <a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html" title="Store the DAP DMR++ metadata responses. ">DmrppMetadataStore</a> using the default values for the cache directory, prefix and size.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html" title="Store the DAP DMR++ metadata responses. ">DmrppMetadataStore</a> object; null if the cache is disabled. </dd></dl>

<p>Definition at line <a class="el" href="../../d1/de4/DmrppMetadataStore_8cc_source.html#l00137">137</a> of file <a class="el" href="../../d1/de4/DmrppMetadataStore_8cc_source.html">DmrppMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa9ae66ea9b3931933f3f4e02562a8d04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> BESFileLockingCache::get_read_lock </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a read-only lock on the file if it exists. </p>
<p>Try to get a read-only lock on the file, blocking until we can get it. If the file does not exist, return false.</p>
<dl class="section note"><dt>Note</dt><dd>If this code returns false, that means the file did not exist in the cache at the time of the test. by the time the caller gets the result, the file may have been added to the cache by another process.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The path of the cached file </td></tr>
    <tr><td class="paramname">fd</td><td>A value-result parameter set to the locked cached file. Undefined if the file could not be locked for read access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file is in the cache and has been locked, false if the file is/was not in the cache. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d9/dd6/classError.html">Error</a></td><td>if the attempt to get the (shared) lock failed for any reason other than that the file does/did not exist. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00537">537</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae1dc85b5343374daa7606de7b8aec69c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">GlobalMetadataStore::MDSReadLock</a> GlobalMetadataStore::get_read_lock_helper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Common code to acquire a read lock on a MDS item. This method locks the response for reading. When the <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html" title="Unlock and close the MDS item when the ReadLock goes out of scope. ">MDSReadLock</a> goes out of scope, the response is unlocked.</p>
<p>This method logs (using LOG, not VERBOSE) cache hits and misses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Granule name </td></tr>
    <tr><td class="paramname">suffix</td><td>One of 'dds_r', 'das_r' or 'dmr_r' </td></tr>
    <tr><td class="paramname">object_name</td><td>One of DDS, DAS or DMR (used for logging only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the object was locked, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00733">733</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a500a4ca2539d42c5aa7c9a702f0647b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BESFileLockingCache::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cache_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an instance of FileLockingCache. </p>
<p>Initialize and instance of FileLockingCache using the passed values for the cache directory, item prefix and max cache size. This will ignore the value of enable_cache() (but will correctly (re)set it based on the directory, ..., values). This provides a way for clients to re-initialize caches on the fly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_dir</td><td>The directory into which the cache files will be written. </td></tr>
    <tr><td class="paramname">prefix</td><td>The prefix that will be added to each cache file. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the cache in MBytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d9/d82/classBESInternalError.html" title="exception thrown if internal error encountered ">BESInternalError</a></td><td>If the cache_dir does not exist or is not writable. size is 0, or if cache dir does not exist. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d7/dbd/classBESError.html" title="Abstract exception class for the BES with basic string message. ">BESError</a></td><td>If the parameters (directory, ...) are invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00116">116</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a58f94ba8d66305a2eb9b9da379373fa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GlobalMetadataStore::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure the ledger using LEDGER_KEY and LOCAL_TIME_KEY. </p>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00366">366</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aaedb248a891f302e279837afd667ed86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GlobalMetadataStore::insert_xml_base </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xml_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>like <a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#a4276dbea6b47169a7a3f5877228d74ef">transfer_bytes()</a>, but adds the xml:base attribute to the DMR/++ </p>
<dl class="section note"><dt>Note</dt><dd>This is a static method so the function will be scoped with this class.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>Open file descriptor to read from; assumed open and positioned at the start of the file. </td></tr>
    <tr><td class="paramname">os</td><td>Write to this C++ stream </td></tr>
    <tr><td class="paramname">xml_base</td><td>Value of the xml:base attribute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d9/d82/classBESInternalError.html" title="exception thrown if internal error encountered ">BESInternalError</a></td><td>Thrown if there's a problem reading or writing. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00157">157</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aed6ab8066b0cd04b49dccfb9612bf139"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> GlobalMetadataStore::is_available_helper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>realName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>relativeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function that checks if last modified time is greater than cached file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">realName</td><td>- complete path to file used to find actual file </td></tr>
    <tr><td class="paramname">relativeName</td><td>- relative filename used to find cached file </td></tr>
    <tr><td class="paramname">fileType</td><td>- used to retrieve correct <a class="el" href="../../d7/db0/classBESRequestHandler.html" title="Represents a specific data type request handler. ">BESRequestHandler</a> from <a class="el" href="../../db/dcb/classBESRequestHandlerList.html" title="The list of registered request handlers for this server; a singleton. ">BESRequestHandlerList</a> </td></tr>
    <tr><td class="paramname">suffix</td><td>- One of 'dmr_r', 'dds_r', 'das_r' or 'dmrpp_r'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if actual file has been modified since cached file has been created, false otherwiseS </dd></dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00971">971</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae7cf29d8fdac3b7e8bcb107b60e8cb40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">GlobalMetadataStore::MDSReadLock</a> GlobalMetadataStore::is_das_available </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the DAS response for. </p>
<p>- 6.25.19 SBL </p><ul>
<li>name in the MDS? <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Find the DAS response for </td></tr>
  </table>
  </dd>
</dl>
</li>
<li>name. <dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html" title="Unlock and close the MDS item when the ReadLock goes out of scope. ">MDSReadLock</a> object. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#ae6204dcd40cf3c94efdcf82bc6c08076" title="Is the DMR response for. ">is_dmr_available()</a> for more information. </dd></dl>
</li>
</ul>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00881">881</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="acf9075d8a40a9a53ed82e78cc8685fe2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">GlobalMetadataStore::MDSReadLock</a> GlobalMetadataStore::is_dds_available </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the DDS response for. </p>
<p>- 6.25.19 SBL </p><ul>
<li>name in the MDS? <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Find the DDS response for </td></tr>
  </table>
  </dd>
</dl>
</li>
<li>name. <dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html" title="Unlock and close the MDS item when the ReadLock goes out of scope. ">MDSReadLock</a> object. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#ae6204dcd40cf3c94efdcf82bc6c08076" title="Is the DMR response for. ">is_dmr_available()</a> for more information. </dd></dl>
</li>
</ul>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00834">834</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aedc0e105d6216fc7995f418380ffd310"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">GlobalMetadataStore::MDSReadLock</a> GlobalMetadataStore::is_dds_available </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d74/classBESContainer.html">BESContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the DDS response for. </p>
<ul>
<li>name in the MDS?</li>
</ul>
<p>This is the preferred method since it checks the LMT of the underlying dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Find the DDS response for the dataset in <ul>
<li>container. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html" title="Unlock and close the MDS item when the ReadLock goes out of scope. ">MDSReadLock</a> object. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d91/classbes_1_1GlobalMetadataStore.html#ae6204dcd40cf3c94efdcf82bc6c08076" title="Is the DMR response for. ">is_dmr_available()</a> for more information. </dd></dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00850">850</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae6204dcd40cf3c94efdcf82bc6c08076"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">GlobalMetadataStore::MDSReadLock</a> GlobalMetadataStore::is_dmr_available </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the DMR response for. </p>
<p>- 6.25.19 SBL </p><ul>
<li>name in the MDS?</li>
</ul>
<p>Look in the MDS to see if the DMR response has been stored/cached for </p><ul>
<li>name.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This method and the matching methods for the DDS and DAS use LOG() to record cache hits and misses. Other methods also record information about cache hits, but only using VERBOSE(), so that output will not show up in a normal log.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Find the DMR response for <ul>
<li>name. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html" title="Unlock and close the MDS item when the ReadLock goes out of scope. ">MDSReadLock</a> object. This object is true if the item was found (and a read lock was obtained), false if either of those things are not true. When the <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html" title="Unlock and close the MDS item when the ReadLock goes out of scope. ">MDSReadLock</a> object goes out of scope, the read lock is released. </dd></dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00773">773</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac21a47ed48b30dec2238e7ac0d1878c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html">GlobalMetadataStore::MDSReadLock</a> GlobalMetadataStore::is_dmrpp_available </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the DMR++ response for. </p>
<p>- 6.25.19 SBL </p><ul>
<li>name in the MDS?</li>
</ul>
<p>Look in the MDS to see if the DMR++ response has been stored/cached for </p><ul>
<li>name.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This method uses LOG() to record cache hits and misses. Other methods also record information about cache hits, but only using VERBOSE(), so that output will not show up in a normal log.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Find the DMR++ response for <ul>
<li>name. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html" title="Unlock and close the MDS item when the ReadLock goes out of scope. ">MDSReadLock</a> object. This object is true if the item was found (and a read lock was obtained), false if either of those things are not true. When the <a class="el" href="../../d4/d69/structbes_1_1GlobalMetadataStore_1_1MDSReadLock.html" title="Unlock and close the MDS item when the ReadLock goes out of scope. ">MDSReadLock</a> object goes out of scope, the read lock is released. </dd></dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00930">930</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae2dd8d01a9c4cafdb28d2a7c1490fe89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> BESFileLockingCache::is_unlimited </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this cache allowed to store as much as it wants? </p>
<p>If the size of the cache is zero bytes, then it is allowed to grow with out bounds.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the cache is unlimited in size, false if values will be purged after a preset size is exceeded. </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d28/BESFileLockingCache_8h_source.html#l00177">177</a> of file <a class="el" href="../../d5/d28/BESFileLockingCache_8h_source.html">BESFileLockingCache.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac962a660afcac0159cae6d56f739a74c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BESFileLockingCache::lock_cache_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a shared lock on the 'cache info' file. </p>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00661">661</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a662d290c14ded24e4038732c5d2667b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BESFileLockingCache::lock_cache_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an exclusive lock on the 'cache info' file. The 'cache info' file is used to control certain cache actions, ensuring that they are atomic. These include making sure that the <a class="el" href="../../dd/d75/classBESFileLockingCache.html#a9e12d93d7fe5f5f03190f92362773050" title="Create a file in the cache and lock it for write access. ">create_and_lock()</a> and read_and_lock() operations are atomic as well as the purge and related operations.</p>
<dl class="section note"><dt>Note</dt><dd>This is intended to be used internally only but might be useful in some settings. </dd></dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00646">646</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af097935543e9f85317b6751ac9d20a88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BESFileLockingCache::purge_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Purge a single file from the cache. </p>
<p>Purge a single file from the cache. The file might be old, etc., and need to be removed. Don't use this to shrink the cache when it gets too big, use <a class="el" href="../../dd/d75/classBESFileLockingCache.html#afd7797d9ecb3d4daf0efc9e4ca0a36ce" title="Purge files from the cache. ">update_and_purge()</a> instead since that file optimizes accesses to the cache control file for several changes in a row.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The name of the file to purge. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l01078">1078</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac0f813db1d70c89a09ea98a33e34cc57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> GlobalMetadataStore::remove_response_helper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Common code to remove a stored response.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Granule name </td></tr>
    <tr><td class="paramname">suffix</td><td>One of 'dds_r', 'das_r' or 'dmr_r' </td></tr>
    <tr><td class="paramname">object_name</td><td>One of DDS, DAS or DMR </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l01155">1155</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a4ba0172669af0bfa54c6ca4a5bc729ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> GlobalMetadataStore::remove_responses </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all cached responses and objects for a granule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l01177">1177</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a96e5d3fb5124799535bc5c7dfcf8008e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> GlobalMetadataStore::store_dap_response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d0a/structbes_1_1GlobalMetadataStore_1_1StreamDAP.html">StreamDAP</a> &amp;&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>response_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the DAP metadata responses</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>A child instance of <a class="el" href="../../d8/d0a/structbes_1_1GlobalMetadataStore_1_1StreamDAP.html">StreamDAP</a>, instantiated using a DDS or DMR. An instance of <a class="el" href="../../d0/d01/structbes_1_1GlobalMetadataStore_1_1StreamDDS.html" title="Instantiate with a DDS or DMR and use to write the DDS response. ">StreamDDS</a> will write a DDS response, <a class="el" href="../../d4/d43/structbes_1_1GlobalMetadataStore_1_1StreamDAS.html" title="Instantiate with a DDS or DMR and use to write the DAS response. ">StreamDAS</a> writes a DAS response,and <a class="el" href="../../d8/dc3/structbes_1_1GlobalMetadataStore_1_1StreamDMR.html" title="Instantiate with a DDS or DMR and use to write the DMR response. ">StreamDMR</a> writes a DMR response. </td></tr>
    <tr><td class="paramname">key</td><td>Unique Id for this response; used to store the response in the MDS. </td></tr>
    <tr><td class="paramname">name</td><td>The granule/file name or pathname </td></tr>
    <tr><td class="paramname">response_name</td><td>The name of the particular response (DDS, DAS, DMR). Used for log messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation succeeded, False if the key is in use. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d9/d82/classBESInternalError.html" title="exception thrown if internal error encountered ">BESInternalError</a></td><td>If ... </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00560">560</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a4276dbea6b47169a7a3f5877228d74ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GlobalMetadataStore::transfer_bytes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Hacked from GNU wc (in coreutils). This was found to be faster than a memory mapped file read.</p>
<p><a href="https://stackoverflow.com/questions/17925051/fast-textfile-reading-in-c">https://stackoverflow.com/questions/17925051/fast-textfile-reading-in-c</a></p>
<dl class="section note"><dt>Note</dt><dd>This is a static method so the function will be scoped with this class.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>Open file descriptor to read from; assumed open and positioned at the start of the file. </td></tr>
    <tr><td class="paramname">os</td><td>Write to this C++ stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d9/d82/classBESInternalError.html" title="exception thrown if internal error encountered ">BESInternalError</a></td><td>Thrown if there's a problem reading or writing. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00121">121</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5777955384b133127a2518f44ea28444"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BESFileLockingCache::unlock_and_close </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlock the named file.</p>
<p>This does not do any name mangling; it just closes and unlocks whatever is named (or throws BESBESInternalErroror if the file cannot be closed). If the file was opened more than once, all descriptors are closed. If you need to close a specific descriptor, use the other version of <a class="el" href="../../dd/d75/classBESFileLockingCache.html#a5777955384b133127a2518f44ea28444">unlock_and_close()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method assumes that the file was opened/locked using one of read_and_lock() or <a class="el" href="../../dd/d75/classBESFileLockingCache.html#a9e12d93d7fe5f5f03190f92362773050" title="Create a file in the cache and lock it for write access. ">create_and_lock()</a>. Those methods record the name/file- descriptor pairs so that the files can be properly closed and locks released.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>The name of the file to unlock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">BESBESInternalErroror</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00705">705</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a1a70fdaa70577bd545eb842015bb85b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BESFileLockingCache::unlock_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlock the cache info file.</p>
<dl class="section note"><dt>Note</dt><dd>This is intended to be used internally only but might be useful in some settings. </dd></dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00678">678</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="afd7797d9ecb3d4daf0efc9e4ca0a36ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BESFileLockingCache::update_and_purge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Purge files from the cache. </p>
<p>Purge files, oldest to newest, if the current size of the cache exceeds the size of the cache specified in the constructor. This method uses an exclusive lock on the cache for the duration of the purge process.</p>
<dl class="section note"><dt>Note</dt><dd>If the cache size in bytes is zero, calling this method has no affect (the cache is unlimited in size). Other public methods like <a class="el" href="../../dd/d75/classBESFileLockingCache.html#a5bf293b1c39103e9d6d0fcb88edabe6a" title="Update the cache info file to include &#39;target&#39;. ">update_cache_info()</a> and <a class="el" href="../../dd/d75/classBESFileLockingCache.html#a20d19ed9a8c96bedf8422316b3e8fafa" title="Get the cache size. ">get_cache_size()</a> still work, however.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>Do not delete this file. The name of a file this process just added to the cache. Using fcntl(2) locking there is no way this process can detect its own lock, so the shared read lock on the new file won't keep this process from deleting it (but will keep other processes from deleting it). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00931">931</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5bf293b1c39103e9d6d0fcb88edabe6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long BESFileLockingCache::update_cache_info </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the cache info file to include 'target'. </p>
<p>Add the size of the named file to the total cache size recorded in the cache info file. The cache info file is exclusively locked by this method for its duration. This updates the cache info file and returns the new size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The name of the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new size of the cache </dd></dl>

<p>Definition at line <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html#l00729">729</a> of file <a class="el" href="../../d3/d12/BESFileLockingCache_8cc_source.html">BESFileLockingCache.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab6bf1be061daa2001bef3aa923e558f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GlobalMetadataStore::write_das_response </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the stored DAS response to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The (path)name of the granule </td></tr>
    <tr><td class="paramname">os</td><td>Write to this stream </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l01096">1096</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a4fc23c9c17aefe24166186372b18c4d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GlobalMetadataStore::write_dds_response </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the stored DDS response to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The (path)name of the granule </td></tr>
    <tr><td class="paramname">os</td><td>Write to this stream </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l01084">1084</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a1e641d7d6f51d95196bec3b413f9bd17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GlobalMetadataStore::write_dmr_response </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the stored DMR response to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The (path)name of the granule </td></tr>
    <tr><td class="paramname">os</td><td>Write to this stream </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l01108">1108</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af1f19d5509fba49757b1c342b2314269"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GlobalMetadataStore::write_dmrpp_response </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the stored DMR++ response to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The (path)name of the granule </td></tr>
    <tr><td class="paramname">os</td><td>Write to this stream </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l01131">1131</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a86e416cb60cae7c0f67d1811322e7ab0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GlobalMetadataStore::write_ledger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the current text of d_ledger_entry to the metadata store ledger </p>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l00446">446</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a2eea0ad3d494d430d84c94509d91ae54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GlobalMetadataStore::write_response_helper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Common code to copy a response to an output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Granule name </td></tr>
    <tr><td class="paramname">os</td><td>Write the response to this stream </td></tr>
    <tr><td class="paramname">suffix</td><td>One of 'dds_r', 'das_r' or 'dmr_r' </td></tr>
    <tr><td class="paramname">object_name</td><td>One of DDS, DAS or DMR; used for error reporting. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l01022">1022</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a85a743c4026bbf299344def17376bc56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GlobalMetadataStore::write_response_helper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xml_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version looks at the first few bytes and substitutes a new value for xml:base. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Granule name </td></tr>
    <tr><td class="paramname">os</td><td>Write the response to this stream </td></tr>
    <tr><td class="paramname">suffix</td><td>One of 'dds_r', 'das_r' or 'dmr_r' </td></tr>
    <tr><td class="paramname">xml_base</td><td>Value of the xml:base attribute in the &lt;Dataset...&gt; element </td></tr>
    <tr><td class="paramname">object_name</td><td>One of DDS, DAS or DMR; used for error reporting. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html#l01052">1052</a> of file <a class="el" href="../../d3/da0/GlobalMetadataStore_8cc_source.html">GlobalMetadataStore.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="../../df/d52/DmrppMetadataStore_8h_source.html">DmrppMetadataStore.h</a></li>
<li><a class="el" href="../../d1/de4/DmrppMetadataStore_8cc_source.html">DmrppMetadataStore.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>bes</b></li><li class="navelem"><a class="el" href="../../de/d7d/classbes_1_1DmrppMetadataStore.html">DmrppMetadataStore</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
